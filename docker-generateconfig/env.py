#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import json
import requests
import re

cfg = {
    'inputFile': '.env.default',
    'overrideFile': '.env.override',
    'outputFile': '.env',

    # Mapping of env variable → API version key
    'overrideVarMap': {
        'ANY_SYNC_NODE_VERSION': 'pkg::any-sync-node',
        'ANY_SYNC_FILENODE_VERSION': 'pkg::any-sync-filenode',
        'ANY_SYNC_COORDINATOR_VERSION': 'pkg::any-sync-coordinator',
        'ANY_SYNC_CONSENSUSNODE_VERSION': 'pkg::any-sync-consensusnode',
    },

    # Default versions to use if API is unavailable (values without leading 'v')
    'defaultVersions': {
        'ANY_SYNC_NODE_VERSION': '0.10.1',
        'ANY_SYNC_FILENODE_VERSION': '0.10.0',
        'ANY_SYNC_COORDINATOR_VERSION': '0.8.0',
        'ANY_SYNC_CONSENSUSNODE_VERSION': '0.5.0',
    },

    # API endpoints for version maps
    'versionsUrlMap': {
        'prod': 'https://puppetdoc.anytype.io/api/v1/prod-any-sync-compatible-versions/',
        'stage1': 'https://puppetdoc.anytype.io/api/v1/stage1-any-sync-compatible-versions/',
    },

    # Header to prepend to the generated output file
    'outputFileHeader': '''# !!! PLEASE DO NOT EDIT THIS FILE !!!
# To make changes to the '.env', use the '.env.override' file
# https://github.com/anyproto/any-sync-dockercompose/wiki/Configuration

''',
}

# Load variables from inputFile
envVars = dict()
if os.path.exists(cfg['inputFile']) and os.path.getsize(cfg['inputFile']) > 0:
    with open(cfg['inputFile']) as file:
        for line in file:
            # Skip comments and empty lines
            if line.startswith('#') or not line.strip():
                continue

            # Parse KEY=VALUE pairs
            key, value = line.strip().split('=', 1)
            if key in envVars:
                print(f"WARNING: duplicate key={key} in env file={cfg['inputFile']}")
            envVars[key] = value
else:
    print(f"ERROR: file={cfg['inputFile']} not found or size=0")
    exit(1)

# Override variables from overrideFile (if present)
if os.path.exists(cfg['overrideFile']) and os.path.getsize(cfg['overrideFile']) > 0:
    with open(cfg['overrideFile']) as file:
        for line in file:
            # Skip comments and empty lines
            if line.startswith('#') or not line.strip():
                continue

            key, value = line.strip().split('=', 1)
            envVars[key] = value

# Perform API request; return None on failure
def apiRequest(url):
    try:
        response = requests.get(url, timeout=(3.05, 5))
    except Exception as e:
        print(f"failed response url={url}, error={str(e)}")
        return None

    if response.status_code != 200:
        print(f"failed response url={url}, status_code={response.status_code}, text={response.text}")
        return None

    try:
        jsonResponse = response.json()
    except Exception as e:
        print(f"failed parse json url={url}, error={str(e)}")
        return None

    return jsonResponse

# Fetch latest compatible versions for a given environment ("prod", "stage1")
def getLatestVersions(role):
    versions = apiRequest(cfg['versionsUrlMap'][role])
    if not versions:
        return None

    try:
        # API returns timestamps as string keys; sort numerically
        sortedVersions = dict(sorted(versions.items(), key=lambda x: int(x[0])))

        # Take the last (latest) timestamp entry
        lastVersionsTimestamp, lastVersions = next(reversed(sortedVersions.items()))
    except Exception as e:
        print(f"failed to process versions for role={role}, error={str(e)}")
        return None

    return lastVersions

# Process variables that may require version substitution
for key, value in envVars.items():
    if key in cfg['overrideVarMap'].keys():
        # value must match an API environment key ("prod", "stage1")
        if value in cfg['versionsUrlMap'].keys():
            latestVersions = getLatestVersions(value)

            if latestVersions:
                lastVersionKey = cfg['overrideVarMap'].get(key)
                lastVersionValue = latestVersions.get(lastVersionKey)

                # If API returned a valid version → use it
                if lastVersionKey and lastVersionValue:
                    envVars[key] = 'v' + str(lastVersionValue)
                    continue  # Continue to next env variable

            # Fallback: use default version from config if API failed
            defaultVersion = cfg.get('defaultVersions', {}).get(key)
            if defaultVersion:
                print(f"using default version for {key}: {defaultVersion}")
                envVars[key] = 'v' + str(defaultVersion)

# Write final env file
with open(cfg['outputFile'], 'w') as file:
    file.write(cfg['outputFileHeader'])
    for key, value in envVars.items():
        file.write(f"{key}={value}\n")
